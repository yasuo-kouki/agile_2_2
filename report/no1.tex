\section*{はじめに}

 実験の目的
    データ圧縮がなぜ必要か
 実験の理論
    どのような方式を適用するか調査・選択し記載する
    確定できない場合、複数の方式を記載してもよい
 実験方法
    プログラムの実装、性能確認方法
    複数の方式を試す場合、方式の選択基準


現代社会ではiotの普及が進み，様々なセンサーから大量のデータが生成されている．
これらのデータを効率的に保存・伝送するためには，データ圧縮技術が不可欠である．
本実験では，代表的なデータ圧縮方式を調査し，その性能を比較・評価することを目的とする．

スパース化をして，0.01\%以下のゼロ要素を持つ行列を対象とする．
圧縮方法には，CSR形式を採用することにした．CSR形式は，疎行列の非ゼロ要素のみを格納することで，
メモリ使用量を削減できるため，データ圧縮に適している．他の圧縮方式のDense形式やCOO形式も検討したが，
今回扱うデータは疎のデータが多くあるため，CSR形式が最も効果的であると判断した．
また，量子化も有効的な手段であるため，本実験では量子化も併用することとした．
今の実装のコードはfloat型で実装しており，char型を採用することでメモリを削減できると考えたためである．
また，縦行列の重みの保存は同じ値が多くあることも確認できたため，ランレングス圧縮も適用することとした．
これらの方式は同時に実装できるため，組み合わせて使用することとした．

本実験では，Pythonを用いて各圧縮方式のプログラムを実装し，性能確認を行う．
性能は，圧縮率と復元精度を評価指標とし，異なる圧縮方式の組み合わせに対して比較を行う．
復元精度は，元のデータと復元データの平均二乗誤差（MSE）を計算することで評価する．
参考文献を用いて，復元精度の許容度を決める．




\section*{はじめに}
現代社会において IoT 機器の普及は著しく，様々なセンサーから継続的に大量のデータが生成されている．これらのデータは記録や解析，遠隔伝送といった用途で広く活用される一方で，ストレージ容量や通信帯域の制約が現実上の課題となる．したがって，データを効率的に保存・伝送するための圧縮技術は不可欠である．本研究では，特に高い疎性を持つ行列データを対象として，代表的な圧縮方式を調査し，Python による実装を通じて圧縮率と復元精度を定量的に評価することを目的とする．なお，原資料にある「0.01%以下のゼロ要素」という表現は解釈が分かれるため，本稿では「非ゼロ要素比が非常に小さい，すなわち高い疎性を持つ行列」を対象とする前提で記述する．必要に応じてこの前提は明示的に変更する．

\section{実験の目的}
本実験の目的は，IoT センサ等から得られる疎行列データに対して実用的かつ効率的な圧縮方式を選定し，その実装と評価を通じて各方式の利点と欠点を明確にすることである．具体的には，疎データに適した行列表現や値の量子化，および連続値に対する圧縮手法を組合せて実装し，圧縮後のデータサイズと復元時の誤差（主に平均二乗誤差; MSE），さらに圧縮および復元に要する処理時間とメモリ使用量を測定する．これらの評価結果に基づいて，ユースケース別（長期保存，リアルタイム伝送，組み込みデバイス等）の推奨方式を導出することを目指す．

\section{実験の理論}
本節では本実験で検討する圧縮方式について理論的な背景と選定理由を述べる．まず疎行列表現としては CSR（Compressed Sparse Row）形式を中心に採用する．CSR は各行ごとの非ゼロ要素の値配列と対応する列インデックス，および行の開始位置を保持する方式であり，行単位のアクセスや演算が多い場合にメモリ効率が高い．本対象データは行方向にゼロが多く存在することが想定されるため，非ゼロ要素のみを格納する CSR によって顕著なメモリ削減が期待できる．一方，実装の簡潔さや一部の操作での利便性を担保する比較対象として COO（Coordinate）形式も評価対象とし，Dense 形式はベースラインとして保持する．

次に値領域の削減手法として量子化を採用する．量子化は浮動小数点値を低ビット幅の整数表現へ写像することでビット数を削減する手法であり，許容誤差の範囲内でビット幅を縮小できれば保存容量を大幅に削減できる．本実験ではまず均一量子化（線形スケーリング）を基本手法として適用し，必要に応じて非線形な量子化方式も検討する．量子化の効果は MSE によって評価する．

さらに，縦列や行方向に同一値が連続する傾向が観察されるため，ランレングス圧縮（RLE）も検討する．RLE は連続する同一値を「値＋長さ」の対で表現する単純な手法であり，連続性の強い領域に対して有効である．これらの方式は互いに排他的ではなく，CSR による非ゼロ要素抽出の後にデータ部へ量子化を適用し，その後に RLE を適用するというパイプラインが合理的であると考えられる．この際，適用順序や組合せの有効性は実データ特性に依存するため，実験により比較評価を行う．

\section{実験方法}
実験は Python を用いて実施する．主要ライブラリとして NumPy および SciPy の \texttt{scipy.sparse} を利用し，CSR／COO の既存実装と，自前で保存フォーマットを設計した実装を比較する．データセットは実データの利用を優先するが，解析の再現性と特性評価のために疎度や値分布，連続性を制御できる合成データも作成する．合成データは複数の疎度（例：非ゼロ要素比が 0.01% 程度〜数パーセント），異なる値分布（正規分布，離散分布），および連続値の頻度を変えて用意する．

実装における主要な流れは，まず元データのスパース化（必要に応じて閾値処理を行い一定の要素をゼロ化）を行い，続いて CSR 形式へ変換する段階，CSR の \texttt{data} 部分へ均一量子化を適用して整数化する段階，さらに同一値が連続する箇所が多ければ RLE を適用する段階という順で進める．パイプライン全体に対しては，量子化ビット幅や RLE の適用基準といったハイパーパラメータを変化させ，圧縮率と復元 MSE，圧縮／復元処理時間，およびピークメモリ使用量を測定する．これらの計測には標準的な時間計測関数と，メモリ計測のためのツールを併用する．

評価指標としては圧縮率をまず定義し，ここでは圧縮率を「圧縮後のバイト数を元データのバイト数で割った値」として扱う．圧縮率が小さいほど高圧縮であると判断する．復元精度は平均二乗誤差（MSE）を主指標とし，必要に応じてピーク信号対雑音比（PSNR）や平均相対誤差も補助指標として併記する．さらに，圧縮および復元に要する処理時間とピークメモリ使用量を評価に加えることで，実用面でのトレードオフを明確にする．

実験の手順は次の通りである．まずデータを準備し，Dense 保存と CSR，COO の各単独方式についてベースライン測定を行う．次に量子化ビット幅を変化させた場合の圧縮率と MSE を計測し，RLE の有無による差分を比較する．最後に CSR+量子化，CSR+RLE，および CSR+量子化+RLE の組合せごとに最良パラメータを探索し，各方式の優劣と適用条件を整理する．得られた結果は表形式と図表で示し，圧縮率と復元誤差のトレードオフを詳細に解析する．

\section{方式選択の基準と期待される結果}
用途別の選択基準として，保存容量や通信帯域が制約される場面では圧縮率を重視し，許容される MSE の上限を事前に設定したうえで量子化を強める方向を推奨する．逆に復元精度が厳格に求められる場面では，CSR 単独や低圧縮量の量子化を採用し，必要に応じて RLE を併用することが望ましい．組み込みデバイスのように計算資源が限られる環境では，計算コストの低い方式を優先し，複雑なポストプロセスを避けるべきである．

期待される実験結果としては，CSR が高い疎度に対して優れた圧縮率を示す一方，量子化ビット幅を下げると MSE が増加するため明確なトレードオフが得られることが予想される．RLE は同一値の連続が多いデータで大きな効果を示すと期待されるため，縦列に定数的な要素が現れるセンサ行列では特に有効であると考えられる．

\section*{報告形式の提案}
実験結果の報告には，方式ごとの圧縮後サイズ，圧縮率，MSE，処理時間，メモリ使用量をまとめた表を含めることを提案する．また，量子化ビット幅と MSE の関係を示すトレードオフ図や，復元前後の値分布を比較するヒストグラム，残差プロット等を示すことで読者に直感的な理解を促す．実験で参照した文献やライブラリドキュメントは参考文献欄に追記する．

\section*{参考文献}
本稿で述べた理論背景や実装手法の詳細については，疎行列表現とデータ圧縮に関する標準的な教科書や査読論文，および SciPy 等のライブラリドキュメントを参照する．具体的な文献リストは実験で使用した資料が確定次第追記する．